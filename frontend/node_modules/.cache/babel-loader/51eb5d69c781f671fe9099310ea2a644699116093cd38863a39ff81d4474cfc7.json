{"ast":null,"code":"import { getAngle as t, radianToAngle as n, getVLength as e, getDirection as o } from \"@any-touch/vector\";\nimport { TYPE_START as r, TYPE_MOVE as i, CLIENT_X as a, CLIENT_Y as c, round2 as u, COMPUTE_INTERVAL as s } from \"@any-touch/shared\";\nfunction p() {\n  let n = 0,\n    e = 0;\n  return function (o, r) {\n    const {\n      prevVecotr: i,\n      startVecotr: a,\n      activeVecotr: c\n    } = r;\n    return c && (e = Math.round(t(c, i)), n = Math.round(t(c, a))), {\n      angle: n,\n      deltaAngle: e\n    };\n  };\n}\nfunction d() {\n  return function (t) {\n    const {\n      prevInput: e\n    } = t;\n    let o = 0,\n      r = 0,\n      i = 0;\n    if (void 0 !== e && (o = t.x - e.x, r = t.y - e.y, 0 !== o || 0 !== r)) {\n      const t = Math.sqrt(Math.pow(o, 2) + Math.pow(r, 2));\n      i = Math.round(n(Math.acos(Math.abs(o) / t)));\n    }\n    return {\n      deltaX: o,\n      deltaY: r,\n      deltaXYAngle: i\n    };\n  };\n}\nfunction h() {\n  let t,\n    n = 0,\n    u = 0,\n    s = 0,\n    p = 0,\n    d = 0;\n  return function (h) {\n    const {\n      phase: l,\n      startInput: f\n    } = h;\n    return r === l ? (n = 0, u = 0, s = 0, p = 0, d = 0) : i === l && (n = Math.round(h.points[0][a] - f.points[0][a]), u = Math.round(h.points[0][c] - f.points[0][c]), s = Math.abs(n), p = Math.abs(u), d = Math.round(e({\n      x: s,\n      y: p\n    })), t = o(n, u)), {\n      displacementX: n,\n      displacementY: u,\n      distanceX: s,\n      distanceY: p,\n      distance: d,\n      overallDirection: t\n    };\n  };\n}\nfunction l() {\n  let t = 1;\n  return function (n, o) {\n    let r = 1;\n    const {\n      prevVecotr: i,\n      startVecotr: a,\n      activeVecotr: c\n    } = o;\n    return c && (r = u(e(c) / e(i)), t = u(e(c) / e(a))), {\n      scale: t,\n      deltaScale: r\n    };\n  };\n}\nfunction f() {\n  let t,\n    n,\n    e = 0,\n    r = 0,\n    i = 0,\n    a = 0;\n  return function (c) {\n    if (void 0 !== c) {\n      n = n || c.startInput;\n      const u = c.timestamp - n.timestamp;\n      if (s < u) {\n        const s = c.x - n.x,\n          p = c.y - n.y;\n        i = Math.round(s / u * 100) / 100, a = Math.round(p / u * 100) / 100, e = Math.abs(i), r = Math.abs(a), t = o(s, p), n = c;\n      }\n    }\n    return {\n      velocityX: e,\n      velocityY: r,\n      speedX: i,\n      speedY: a,\n      direction: t\n    };\n  };\n}\nfunction M() {\n  let t = 0;\n  return function (n) {\n    const {\n      phase: e\n    } = n;\n    return r === e && (t = n.pointLength), {\n      maxPointLength: t\n    };\n  };\n}\nfunction v(t) {\n  return {\n    x: t.points[1][a] - t.points[0][a],\n    y: t.points[1][c] - t.points[0][c]\n  };\n}\nfunction m() {\n  let t, n, e;\n  return function (o) {\n    const {\n      prevInput: r,\n      startMultiInput: i\n    } = o;\n    return void 0 !== i && void 0 !== r && o.id !== i.id && 1 < r.pointLength && 1 < o.pointLength ? (t = v(i), n = v(r), e = v(o)) : e = void 0, {\n      startVecotr: t,\n      prevVecotr: n,\n      activeVecotr: e\n    };\n  };\n}\nexport { p as ComputeAngle, d as ComputeDeltaXY, h as ComputeDistance, M as ComputeMaxLength, l as ComputeScale, f as ComputeVAndDir, m as ComputeVectorForMutli };","map":{"version":3,"mappings":"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","names":["ComputeAngle","angle","deltaAngle","input","computed","prevVecotr","startVecotr","activeVecotr","Math","round","getAngle","prevInput","deltaX","deltaY","deltaXYAngle","x","y","deltaXY","sqrt","pow","radianToAngle","acos","abs","overallDirection","displacementX","displacementY","distanceX","distanceY","distance","phase","startInput","TYPE_START","TYPE_MOVE","points","CLIENT_X","CLIENT_Y","getVLength","getDirection","scale","deltaScale","round2","direction","lastValidInput","velocityX","velocityY","speedX","speedY","deltaTime","timestamp","COMPUTE_INTERVAL","ComputeMaxLength","maxPointLength","pointLength","computeVector","startMultiInput","id"],"sources":["../../../../packages/compute/src/ComputeAngle.ts","../../../../packages/compute/src/ComputeDeltaXY.ts","../../../../packages/compute/src/ComputeDistance.ts","../../../../packages/compute/src/ComputeScale.ts","../../../../packages/compute/src/ComputeVAndDir.ts","../../../../packages/compute/src/ComputeMaxLength.ts","../../../../packages/compute/src/ComputeVectorForMutli.ts"],"sourcesContent":[null,null,null,null,null,null,null]},"metadata":{},"sourceType":"module","externalDependencies":[]}