{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { defineComponent, ref, computed, onMounted, watch, provide, openBlock, createElementBlock, normalizeClass, unref, normalizeStyle, createCommentVNode, createElementVNode, renderSlot } from 'vue';\nimport { useEventListener } from '@vueuse/core';\nimport '../../../hooks/index.mjs';\nimport '../../../utils/index.mjs';\nimport { anchorProps, anchorEmits } from './anchor.mjs';\nimport { anchorKey } from './constants.mjs';\nimport _export_sfc from '../../../_virtual/plugin-vue_export-helper.mjs';\nimport { useNamespace } from '../../../hooks/use-namespace/index.mjs';\nimport { getElement } from '../../../utils/dom/element.mjs';\nimport { getScrollElement, animateScrollTo, getScrollTop } from '../../../utils/dom/scroll.mjs';\nimport { getOffsetTopDistance } from '../../../utils/dom/position.mjs';\nimport { throttleByRaf } from '../../../utils/throttleByRaf.mjs';\nimport { isUndefined, isWindow } from '../../../utils/types.mjs';\nconst __default__ = defineComponent({\n  name: \"ElAnchor\"\n});\nconst _sfc_main = /* @__PURE__ */defineComponent({\n  ...__default__,\n  props: anchorProps,\n  emits: anchorEmits,\n  setup(__props, {\n    expose,\n    emit\n  }) {\n    const props = __props;\n    const currentAnchor = ref(\"\");\n    const anchorRef = ref(null);\n    const markerRef = ref(null);\n    const containerEl = ref();\n    const links = {};\n    let isScrolling = false;\n    let currentScrollTop = 0;\n    const ns = useNamespace(\"anchor\");\n    const cls = computed(() => [ns.b(), props.type === \"underline\" ? ns.m(\"underline\") : \"\", ns.m(props.direction)]);\n    const addLink = state => {\n      links[state.href] = state.el;\n    };\n    const removeLink = href => {\n      delete links[href];\n    };\n    const setCurrentAnchor = href => {\n      const activeHref = currentAnchor.value;\n      if (activeHref !== href) {\n        currentAnchor.value = href;\n        emit(\"change\", href);\n      }\n    };\n    let clearAnimate = null;\n    const scrollToAnchor = href => {\n      if (!containerEl.value) return;\n      const target = getElement(href);\n      if (!target) return;\n      if (clearAnimate) clearAnimate();\n      isScrolling = true;\n      const scrollEle = getScrollElement(target, containerEl.value);\n      const distance = getOffsetTopDistance(target, scrollEle);\n      const max = scrollEle.scrollHeight - scrollEle.clientHeight;\n      const to = Math.min(distance - props.offset, max);\n      clearAnimate = animateScrollTo(containerEl.value, currentScrollTop, to, props.duration, () => {\n        setTimeout(() => {\n          isScrolling = false;\n        }, 20);\n      });\n    };\n    const scrollTo = href => {\n      if (href) {\n        setCurrentAnchor(href);\n        scrollToAnchor(href);\n      }\n    };\n    const handleClick = (e, href) => {\n      emit(\"click\", e, href);\n      scrollTo(href);\n    };\n    const handleScroll = throttleByRaf(() => {\n      if (containerEl.value) {\n        currentScrollTop = getScrollTop(containerEl.value);\n      }\n      const currentHref = getCurrentHref();\n      if (isScrolling || isUndefined(currentHref)) return;\n      setCurrentAnchor(currentHref);\n    });\n    const getCurrentHref = () => {\n      if (!containerEl.value) return;\n      const scrollTop = getScrollTop(containerEl.value);\n      const anchorTopList = [];\n      for (const href of Object.keys(links)) {\n        const target = getElement(href);\n        if (!target) continue;\n        const scrollEle = getScrollElement(target, containerEl.value);\n        const distance = getOffsetTopDistance(target, scrollEle);\n        anchorTopList.push({\n          top: distance - props.offset - props.bound,\n          href\n        });\n      }\n      anchorTopList.sort((prev, next) => prev.top - next.top);\n      for (let i = 0; i < anchorTopList.length; i++) {\n        const item = anchorTopList[i];\n        const next = anchorTopList[i + 1];\n        if (i === 0 && scrollTop === 0) {\n          return \"\";\n        }\n        if (item.top <= scrollTop && (!next || next.top > scrollTop)) {\n          return item.href;\n        }\n      }\n    };\n    const getContainer = () => {\n      const el = getElement(props.container);\n      if (!el || isWindow(el)) {\n        containerEl.value = window;\n      } else {\n        containerEl.value = el;\n      }\n    };\n    useEventListener(containerEl, \"scroll\", handleScroll);\n    const markerStyle = computed(() => {\n      if (!anchorRef.value || !markerRef.value || !currentAnchor.value) return {};\n      const currentLinkEl = links[currentAnchor.value];\n      if (!currentLinkEl) return {};\n      const anchorRect = anchorRef.value.getBoundingClientRect();\n      const markerRect = markerRef.value.getBoundingClientRect();\n      const linkRect = currentLinkEl.getBoundingClientRect();\n      if (props.direction === \"horizontal\") {\n        const left = linkRect.left - anchorRect.left;\n        return {\n          left: `${left}px`,\n          width: `${linkRect.width}px`,\n          opacity: 1\n        };\n      } else {\n        const top = linkRect.top - anchorRect.top + (linkRect.height - markerRect.height) / 2;\n        return {\n          top: `${top}px`,\n          opacity: 1\n        };\n      }\n    });\n    onMounted(() => {\n      getContainer();\n      const hash = decodeURIComponent(window.location.hash);\n      const target = getElement(hash);\n      if (target) {\n        scrollTo(hash);\n      } else {\n        handleScroll();\n      }\n    });\n    watch(() => props.container, () => {\n      getContainer();\n    });\n    provide(anchorKey, {\n      ns,\n      direction: props.direction,\n      currentAnchor,\n      addLink,\n      removeLink,\n      handleClick\n    });\n    expose({\n      scrollTo\n    });\n    return (_ctx, _cache) => {\n      return openBlock(), createElementBlock(\"div\", {\n        ref_key: \"anchorRef\",\n        ref: anchorRef,\n        class: normalizeClass(unref(cls))\n      }, [_ctx.marker ? (openBlock(), createElementBlock(\"div\", {\n        key: 0,\n        ref_key: \"markerRef\",\n        ref: markerRef,\n        class: normalizeClass(unref(ns).e(\"marker\")),\n        style: normalizeStyle(unref(markerStyle))\n      }, null, 6)) : createCommentVNode(\"v-if\", true), createElementVNode(\"div\", {\n        class: normalizeClass(unref(ns).e(\"list\"))\n      }, [renderSlot(_ctx.$slots, \"default\")], 2)], 2);\n    };\n  }\n});\nvar Anchor = /* @__PURE__ */_export_sfc(_sfc_main, [[\"__file\", \"anchor.vue\"]]);\nexport { Anchor as default };","map":{"version":3,"mappings":"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","names":["name","ref","containerEl","links","isScrolling","currentScrollTop","useNamespace","computed","ns","b","props","type","m","direction","state","href","activeHref","currentAnchor","value","emit","clearAnimate","getElement","target","scrollEle","getOffsetTopDistance","to","Math","distance","offset","max","animateScrollTo","duration","setTimeout","setCurrentAnchor","scrollToAnchor","handleClick","e","scrollTo","throttleByRaf","currentHref","getCurrentHref","isUndefined","getScrollTop","anchorTopList","keys","push","top","sort","prev","next","i","length","item","scrollTop","getContainer","container","el","isWindow","useEventListener","handleScroll","anchorRef","markerRef","currentLinkEl","getBoundingClientRect","linkRect","anchorRect","left","width","opacity","markerRect","height","onMounted","hash","window","watch","provide","anchorKey","addLink","removeLink","expose"],"sources":["../../../../../../packages/components/anchor/src/anchor.vue"],"sourcesContent":["<template>\n  <div ref=\"anchorRef\" :class=\"cls\">\n    <div\n      v-if=\"marker\"\n      ref=\"markerRef\"\n      :class=\"ns.e('marker')\"\n      :style=\"markerStyle\"\n    />\n    <div :class=\"ns.e('list')\">\n      <slot />\n    </div>\n  </div>\n</template>\n\n<script lang=\"ts\" setup>\nimport { computed, onMounted, provide, ref, watch } from 'vue'\nimport { useEventListener } from '@vueuse/core'\nimport { useNamespace } from '@element-plus/hooks'\nimport {\n  animateScrollTo,\n  getElement,\n  getOffsetTopDistance,\n  getScrollElement,\n  getScrollTop,\n  isUndefined,\n  isWindow,\n  throttleByRaf,\n} from '@element-plus/utils'\nimport { anchorEmits, anchorProps } from './anchor'\nimport { anchorKey } from './constants'\n\nimport type { AnchorLinkState } from './constants'\n\ndefineOptions({\n  name: 'ElAnchor',\n})\n\nconst props = defineProps(anchorProps)\nconst emit = defineEmits(anchorEmits)\n\nconst currentAnchor = ref('')\nconst anchorRef = ref<HTMLElement | null>(null)\nconst markerRef = ref<HTMLElement | null>(null)\nconst containerEl = ref<HTMLElement | Window>()\n\nconst links: Record<string, HTMLElement> = {}\nlet isScrolling = false\nlet currentScrollTop = 0\n\nconst ns = useNamespace('anchor')\n\nconst cls = computed(() => [\n  ns.b(),\n  props.type === 'underline' ? ns.m('underline') : '',\n  ns.m(props.direction),\n])\n\nconst addLink = (state: AnchorLinkState) => {\n  links[state.href] = state.el\n}\n\nconst removeLink = (href: string) => {\n  delete links[href]\n}\n\nconst setCurrentAnchor = (href: string) => {\n  const activeHref = currentAnchor.value\n  if (activeHref !== href) {\n    currentAnchor.value = href\n    emit('change', href)\n  }\n}\n\nlet clearAnimate: (() => void) | null = null\n\nconst scrollToAnchor = (href: string) => {\n  if (!containerEl.value) return\n  const target = getElement(href)\n  if (!target) return\n  if (clearAnimate) clearAnimate()\n  isScrolling = true\n  const scrollEle = getScrollElement(target, containerEl.value)\n  const distance = getOffsetTopDistance(target, scrollEle)\n  const max = scrollEle.scrollHeight - scrollEle.clientHeight\n  const to = Math.min(distance - props.offset, max)\n  clearAnimate = animateScrollTo(\n    containerEl.value,\n    currentScrollTop,\n    to,\n    props.duration,\n    () => {\n      // make sure it is executed after throttleByRaf's handleScroll\n      setTimeout(() => {\n        isScrolling = false\n      }, 20)\n    }\n  )\n}\n\nconst scrollTo = (href?: string) => {\n  if (href) {\n    setCurrentAnchor(href)\n    scrollToAnchor(href)\n  }\n}\n\nconst handleClick = (e: MouseEvent, href?: string) => {\n  emit('click', e, href)\n  scrollTo(href)\n}\n\nconst handleScroll = throttleByRaf(() => {\n  if (containerEl.value) {\n    currentScrollTop = getScrollTop(containerEl.value)\n  }\n  const currentHref = getCurrentHref()\n  if (isScrolling || isUndefined(currentHref)) return\n  setCurrentAnchor(currentHref)\n})\n\nconst getCurrentHref = () => {\n  if (!containerEl.value) return\n  const scrollTop = getScrollTop(containerEl.value)\n  const anchorTopList: { top: number; href: string }[] = []\n\n  for (const href of Object.keys(links)) {\n    const target = getElement(href)\n    if (!target) continue\n    const scrollEle = getScrollElement(target, containerEl.value)\n    const distance = getOffsetTopDistance(target, scrollEle)\n    anchorTopList.push({\n      top: distance - props.offset - props.bound,\n      href,\n    })\n  }\n  anchorTopList.sort((prev, next) => prev.top - next.top)\n\n  for (let i = 0; i < anchorTopList.length; i++) {\n    const item = anchorTopList[i]\n    const next = anchorTopList[i + 1]\n\n    if (i === 0 && scrollTop === 0) {\n      return ''\n    }\n    if (item.top <= scrollTop && (!next || next.top > scrollTop)) {\n      return item.href\n    }\n  }\n}\n\nconst getContainer = () => {\n  const el = getElement(props.container)\n  if (!el || isWindow(el)) {\n    containerEl.value = window\n  } else {\n    containerEl.value = el\n  }\n}\n\nuseEventListener(containerEl, 'scroll', handleScroll)\n\nconst markerStyle = computed(() => {\n  if (!anchorRef.value || !markerRef.value || !currentAnchor.value) return {}\n  const currentLinkEl = links[currentAnchor.value]\n  if (!currentLinkEl) return {}\n  const anchorRect = anchorRef.value.getBoundingClientRect()\n  const markerRect = markerRef.value.getBoundingClientRect()\n  const linkRect = currentLinkEl.getBoundingClientRect()\n\n  if (props.direction === 'horizontal') {\n    const left = linkRect.left - anchorRect.left\n    return {\n      left: `${left}px`,\n      width: `${linkRect.width}px`,\n      opacity: 1,\n    }\n  } else {\n    const top =\n      linkRect.top - anchorRect.top + (linkRect.height - markerRect.height) / 2\n    return {\n      top: `${top}px`,\n      opacity: 1,\n    }\n  }\n})\n\nonMounted(() => {\n  getContainer()\n  const hash = decodeURIComponent(window.location.hash)\n  const target = getElement(hash)\n  if (target) {\n    scrollTo(hash)\n  } else {\n    handleScroll()\n  }\n})\n\nwatch(\n  () => props.container,\n  () => {\n    getContainer()\n  }\n)\n\nprovide(anchorKey, {\n  ns,\n  direction: props.direction,\n  currentAnchor,\n  addLink,\n  removeLink,\n  handleClick,\n})\n\ndefineExpose({\n  scrollTo,\n})\n</script>\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}